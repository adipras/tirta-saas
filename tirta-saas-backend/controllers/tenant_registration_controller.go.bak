package controllers

import (
	"net/http"
	"time"

	"github.com/adipras/tirta-saas-backend/config"
	"github.com/adipras/tirta-saas-backend/constants"
	"github.com/adipras/tirta-saas-backend/models"
	"github.com/adipras/tirta-saas-backend/requests"
	"github.com/adipras/tirta-saas-backend/responses"
	"github.com/adipras/tirta-saas-backend/utils"
	"github.com/gin-gonic/gin"
)

// PublicTenantRegistration handles public tenant registration (no authentication required)
// @Summary Public tenant registration
// @Description Register a new tenant organization with admin user
// @Tags Public
// @Accept json
// @Produce json
// @Param request body requests.PublicTenantRegistrationRequest true "Registration data"
// @Success 201 {object} responses.TenantRegistrationResponse
// @Failure 400 {object} responses.ErrorResponse
// @Router /api/public/register [post]
func PublicTenantRegistration(c *gin.Context) {
	var req requests.PublicTenantRegistrationRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, responses.ErrorResponse{
			Status:  "error",
			Message: "Invalid request data",
			Error:   err.Error(),
		})
		return
	}

	// Check if village code already exists
	var existingTenant models.Tenant
	if err := config.DB.Where("village_code = ?", req.VillageCode).First(&existingTenant).Error; err == nil {
		c.JSON(http.StatusBadRequest, responses.ErrorResponse{
			Status:  "error",
			Message: "Village code already registered",
			Error:   "This village code is already taken. Please use a unique code.",
		})
		return
	}

	// Check if admin email already exists
	var existingUser models.User
	if err := config.DB.Where("email = ?", req.AdminEmail).First(&existingUser).Error; err == nil {
		c.JSON(http.StatusBadRequest, responses.ErrorResponse{
			Status:  "error",
			Message: "Email already registered",
			Error:   "This email is already in use. Please use a different email.",
		})
		return
	}

	// Hash password
	hashedPassword, err := utils.HashPassword(req.AdminPassword)
	if err != nil {
		c.JSON(http.StatusInternalServerError, responses.ErrorResponse{
			Status:  "error",
			Message: "Failed to process registration",
			Error:   "Password hashing failed",
		})
		return
	}

	// Calculate trial end date (14 days from now)
	trialEndsAt := time.Now().AddDate(0, 0, 14)

	// Start transaction
	tx := config.DB.Begin()
	defer func() {
		if r := recover(); r != nil {
			tx.Rollback()
		}
	}()

	// Create tenant with TRIAL status
	tenant := models.Tenant{
		Name:         req.OrganizationName,
		VillageCode:  req.VillageCode,
		Email:        req.Email,
		Phone:        req.Phone,
		Address:      req.Address,
		AdminName:    req.AdminName,
		AdminEmail:   req.AdminEmail,
		AdminPhone:   req.AdminPhone,
		Status:       models.TenantStatusTrial,
		RegisteredAt: time.Now(),
		TrialEndsAt:  &trialEndsAt,
	}

	if err := tx.Create(&tenant).Error; err != nil {
		tx.Rollback()
		c.JSON(http.StatusInternalServerError, responses.ErrorResponse{
			Status:  "error",
			Message: "Failed to create tenant",
			Error:   err.Error(),
		})
		return
	}

	// Create admin user
	tenantID := tenant.ID
	adminUser := models.User{
		Name:     req.AdminName,
		Email:    req.AdminEmail,
		Password: hashedPassword,
		Role:     string(constants.RoleTenantAdmin),
		TenantID: &tenantID,
	}

	if err := tx.Create(&adminUser).Error; err != nil {
		tx.Rollback()
		c.JSON(http.StatusInternalServerError, responses.ErrorResponse{
			Status:  "error",
			Message: "Failed to create admin user",
			Error:   err.Error(),
		})
		return
	}

	// Create default tenant settings
	tenantSettings := models.TenantSettings{
		TenantID:            tenant.ID,
		CompanyName:         req.OrganizationName,
		Address:             req.Address,
		Phone:               req.Phone,
		Email:               req.Email,
		InvoiceDueDays:      14,
		LatePenaltyPercent:  2.0,
		LatePenaltyMaxCap:   100000,
		GracePeriodDays:     3,
		TimeZone:            "Asia/Jakarta",
		Language:            "id",
		Currency:            "IDR",
	}

	if err := tx.Create(&tenantSettings).Error; err != nil {
		tx.Rollback()
		c.JSON(http.StatusInternalServerError, responses.ErrorResponse{
			Status:  "error",
			Message: "Failed to create tenant settings",
			Error:   err.Error(),
		})
		return
	}

	// Commit transaction
	if err := tx.Commit().Error; err != nil {
		c.JSON(http.StatusInternalServerError, responses.ErrorResponse{
			Status:  "error",
			Message: "Failed to complete registration",
			Error:   err.Error(),
		})
		return
	}

	// Return success response
	c.JSON(http.StatusCreated, responses.TenantRegistrationResponse{
		Status:  "success",
		Message: "Registration successful! Your trial period starts now. Please login to continue.",
		Tenant: responses.TenantRegistrationInfo{
			ID:          tenant.ID,
			Name:        tenant.Name,
			Email:       tenant.Email,
			Status:      string(tenant.Status),
			TrialEndsAt: tenant.TrialEndsAt,
			AdminEmail:  tenant.AdminEmail,
		},
	})
}

// GetPendingTenants returns list of tenants waiting for approval
// @Summary Get pending tenants
// @Description Get list of tenants with TRIAL or PENDING_VERIFICATION status
// @Tags Platform
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param status query string false "Filter by status (TRIAL, PENDING_VERIFICATION, PENDING_PAYMENT)"
// @Success 200 {object} responses.PendingTenantsListResponse
// @Failure 401 {object} responses.ErrorResponse
// @Router /api/platform/tenants/pending [get]
func GetPendingTenants(c *gin.Context) {
status := c.Query("status")

query := config.DB.Model(&models.Tenant{})

if status != "" {
query = query.Where("status = ?", status)
} else {
// Default: show TRIAL and PENDING_VERIFICATION
query = query.Where("status IN ?", []string{
string(models.TenantStatusTrial),
string(models.TenantStatusPendingVerification),
string(models.TenantStatusPendingPayment),
})
}

var tenants []models.Tenant
if err := query.Order("registered_at DESC").Find(&tenants).Error; err != nil {
c.JSON(http.StatusInternalServerError, responses.ErrorResponse{
Status:  "error",
Message: "Failed to fetch pending tenants",
Error:   err.Error(),
})
return
}

// Convert to response format
pendingTenants := make([]responses.PendingTenantResponse, len(tenants))
for i, t := range tenants {
pendingTenants[i] = responses.PendingTenantResponse{
ID:              t.ID,
Name:            t.Name,
VillageCode:     t.VillageCode,
Email:           t.Email,
Phone:           t.Phone,
Address:         t.Address,
AdminName:       t.AdminName,
AdminEmail:      t.AdminEmail,
AdminPhone:      t.AdminPhone,
Status:          string(t.Status),
RegisteredAt:    t.RegisteredAt,
TrialEndsAt:     t.TrialEndsAt,
PaymentProofURL: t.PaymentProofURL,
TotalUsers:      t.TotalUsers,
TotalCustomers:  t.TotalCustomers,
}
}

c.JSON(http.StatusOK, responses.PendingTenantsListResponse{
Status:  "success",
Data:    pendingTenants,
Total:   len(pendingTenants),
Page:    1,
PerPage: len(pendingTenants),
})
}

// ApproveTenant approves a tenant and activates their subscription
// @Summary Approve tenant
// @Description Approve a pending tenant and set to ACTIVE status
// @Tags Platform
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param id path string true "Tenant ID"
// @Param request body requests.TenantApprovalRequest false "Approval data"
// @Success 200 {object} responses.TenantActionResponse
// @Failure 400,404 {object} responses.ErrorResponse
// @Router /api/platform/tenants/{id}/approve [post]
func ApproveTenant(c *gin.Context) {
tenantID := c.Param("id")

var req requests.TenantApprovalRequest
c.ShouldBindJSON(&req)

var tenant models.Tenant
if err := config.DB.First(&tenant, "id = ?", tenantID).Error; err != nil {
c.JSON(http.StatusNotFound, responses.ErrorResponse{
Status:  "error",
Message: "Tenant not found",
Error:   err.Error(),
})
return
}

// Get platform owner info from context
userID, exists := c.Get("user_id")
if !exists {
c.JSON(http.StatusUnauthorized, responses.ErrorResponse{
Status:  "error",
Message: "User not authenticated",
})
return
}

// Get user email from database
var user models.User
if err := config.DB.First(&user, "id = ?", userID).Error; err != nil {
c.JSON(http.StatusInternalServerError, responses.ErrorResponse{
Status:  "error",
Message: "Failed to get user info",
})
return
}
platformOwner := user.Email

now := time.Now()
subscriptionEnds := now.AddDate(0, 1, 0) // 1 month subscription

// Update tenant status
updates := map[string]interface{}{
"status":                string(models.TenantStatusActive),
"approved_at":           &now,
"approved_by":           &platformOwner,
"subscription_starts_at": &now,
"subscription_ends_at":  &subscriptionEnds,
"subscription_status":   "ACTIVE",
}

if req.SubscriptionPlan != "" {
updates["subscription_plan"] = req.SubscriptionPlan
}

if req.Notes != "" {
updates["notes"] = req.Notes
}

if err := config.DB.Model(&tenant).Updates(updates).Error; err != nil {
c.JSON(http.StatusInternalServerError, responses.ErrorResponse{
Status:  "error",
Message: "Failed to approve tenant",
Error:   err.Error(),
})
return
}

// Reload tenant to get updated data
config.DB.First(&tenant, "id = ?", tenantID)

response := responses.TenantActionResponse{
Status:  "success",
Message: "Tenant approved successfully",
}
response.Tenant.ID = tenant.ID
response.Tenant.Name = tenant.Name
response.Tenant.Status = tenant.Status

c.JSON(http.StatusOK, response)
}

// RejectTenant rejects a tenant registration
// @Summary Reject tenant
// @Description Reject a pending tenant
// @Tags Platform
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param id path string true "Tenant ID"
// @Param request body requests.TenantRejectionRequest true "Rejection reason"
// @Success 200 {object} responses.TenantActionResponse
// @Failure 400,404 {object} responses.ErrorResponse
// @Router /api/platform/tenants/{id}/reject [post]
func RejectTenant(c *gin.Context) {
tenantID := c.Param("id")

var req requests.TenantRejectionRequest
if err := c.ShouldBindJSON(&req); err != nil {
c.JSON(http.StatusBadRequest, responses.ErrorResponse{
Status:  "error",
Message: "Rejection reason is required",
Error:   err.Error(),
})
return
}

var tenant models.Tenant
if err := config.DB.First(&tenant, "id = ?", tenantID).Error; err != nil {
c.JSON(http.StatusNotFound, responses.ErrorResponse{
Status:  "error",
Message: "Tenant not found",
Error:   err.Error(),
})
return
}

// Get platform owner info
platformOwnerEmail, _ := c.Get("user_email")
platformOwner := platformOwnerEmail.(string)

now := time.Now()

// Update tenant
if err := config.DB.Model(&tenant).Updates(map[string]interface{}{
"status":           string(models.TenantStatusInactive),
"rejected_at":      &now,
"rejected_by":      &platformOwner,
"rejection_reason": req.Reason,
}).Error; err != nil {
c.JSON(http.StatusInternalServerError, responses.ErrorResponse{
Status:  "error",
Message: "Failed to reject tenant",
Error:   err.Error(),
})
return
}

config.DB.First(&tenant, "id = ?", tenantID)

response := responses.TenantActionResponse{
Status:  "success",
Message: "Tenant rejected",
}
response.Tenant.ID = tenant.ID
response.Tenant.Name = tenant.Name
response.Tenant.Status = tenant.Status

c.JSON(http.StatusOK, response)
}

// SuspendTenant suspends an active tenant
// @Summary Suspend tenant
// @Description Suspend an active tenant
// @Tags Platform
// @Accept json
// @Produce json
// @Security BearerAuth
// @Param id path string true "Tenant ID"
// @Param request body requests.TenantSuspensionRequest true "Suspension reason"
// @Success 200 {object} responses.TenantActionResponse
// @Failure 400,404 {object} responses.ErrorResponse
// @Router /api/platform/tenants/{id}/suspend [post]
func SuspendTenantByPlatform(c *gin.Context) {
tenantID := c.Param("id")

var req requests.TenantSuspensionRequest
if err := c.ShouldBindJSON(&req); err != nil {
c.JSON(http.StatusBadRequest, responses.ErrorResponse{
Status:  "error",
Message: "Suspension reason is required",
Error:   err.Error(),
})
return
}

var tenant models.Tenant
if err := config.DB.First(&tenant, "id = ?", tenantID).Error; err != nil {
c.JSON(http.StatusNotFound, responses.ErrorResponse{
Status:  "error",
Message: "Tenant not found",
Error:   err.Error(),
})
return
}

now := time.Now()

if err := config.DB.Model(&tenant).Updates(map[string]interface{}{
"status":            string(models.TenantStatusSuspended),
"suspended_at":      &now,
"suspension_reason": req.Reason,
}).Error; err != nil {
c.JSON(http.StatusInternalServerError, responses.ErrorResponse{
Status:  "error",
Message: "Failed to suspend tenant",
Error:   err.Error(),
})
return
}

config.DB.First(&tenant, "id = ?", tenantID)

response := responses.TenantActionResponse{
Status:  "success",
Message: "Tenant suspended",
}
response.Tenant.ID = tenant.ID
response.Tenant.Name = tenant.Name
response.Tenant.Status = tenant.Status

c.JSON(http.StatusOK, response)
}
